---
description: 将自然语言需求转换为EARS（Easy Approach to Requirements Syntax）格式的结构化需求文档，为后续SDD工作流提供高质量输入。
handoffs:
  - label: 创建功能规范
    agent: /speckit.specify
    prompt: 基于EARS需求文档创建功能规范。需求文档路径：
  - label: 审核需求文档
    agent: /speckit.clarify
    prompt: 审核EARS需求文档的完整性和清晰度
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果不为空）。

---

# EARS 需求转换系统

## 概述

此命令用于将用户的自然语言需求描述转换为 **EARS（Easy Approach to Requirements Syntax）格式** 的结构化需求文档。EARS 格式是一种被工业界广泛采用的需求编写方法，对 AI 更友好，能够帮助 AI 更准确地理解需求，从而生成更高质量的功能规范（spec）。

### 为什么使用 EARS 格式？

| 问题 | EARS 如何解决 |
|------|---------------|
| 需求模糊不清 | 使用固定句式模板，强制明确触发条件和系统响应 |
| AI 理解偏差 | 结构化格式减少歧义，提高 AI 理解准确度 |
| 需求遗漏 | 分类模板确保覆盖各类需求场景 |
| 验收标准不明确 | 每条需求天然具有可测试性 |

### 工作流定位

```
[用户需求] → /speckit.ears → [EARS文档] → /speckit.specify → [功能规范] → /speckit.plan → ...
                ↑ 当前命令                    标准SDD工作流 →
```

**说明**：EARS 需求转换是 SDD 标准工作流的**可选前置步骤**，适用于：
- 需求描述较为复杂或模糊
- 需要与业务方确认需求细节
- 希望提高 AI 生成规范的质量

## ⚠️ 关键：输出目录结构

> **🚨 强制约束**
>
> EARS 需求文档存储于 `.docs/EARS/` 目录下，**不在** `.specify/` 或 `specs/` 目录中。
> 这是因为 EARS 格式需求是可选的需求整理工具，不属于 spec-kit 标准工作流的一部分。

```
[项目根目录]/
├── .docs/                             # 文档目录（非SDD核心目录）
│   └── EARS/                          # EARS需求文档目录
│       ├── 001-用户认证.md            # 已编号的需求文档
│       ├── 002-支付集成.md
│       └── ...
├── .specify/                          # SDD配置目录（保持独立）
│   └── ...
└── specs/                             # 功能规范目录（保持独立）
    └── ...
```

---

## 执行流程

### 阶段 0: 需求输入解析

**目标**: 理解用户输入，确定操作模式

#### 步骤 0.1: 解析用户输入

1. **获取用户输入**: 读取 `$ARGUMENTS` 中的内容
2. **判断输入类型**:
   - 如果为空: 提示用户 "请提供需求描述，例如：`/speckit.ears 我需要一个用户登录功能，支持手机号和邮箱登录`"
   - 如果是文件路径: 判断是否为已存在的 EARS 文档，进入修改模式
   - 如果是需求描述: 进入新建模式

#### 步骤 0.2: 检查现有文档

1. **确保目录存在**:
   ```bash
   mkdir -p .docs/EARS
   ```

2. **扫描现有文档**:
   ```bash
   # 获取现有文档列表
   ls -1 .docs/EARS/*.md 2>/dev/null | sort -V
   ```

3. **智能匹配判断**:
   - 分析用户需求的关键词
   - 与现有文档标题进行相似度匹配
   - 如果匹配度 > 80%，询问用户是否要修改现有文档

---

### 阶段 1: EARS 格式转换

**目标**: 将自然语言需求转换为 EARS 格式

#### EARS 五种需求模式

EARS 定义了五种标准的需求句式模式，覆盖所有常见的需求场景：

| 模式 | 关键词 | 适用场景 | 模板 |
|------|--------|----------|------|
| **无条件需求** (Ubiquitous) | 系统应当 | 系统必须始终满足的需求 | `系统应当 <功能>` |
| **事件驱动需求** (Event-Driven) | 当...时 | 特定事件触发的响应 | `当 <触发条件> 时，系统应当 <响应>` |
| **条件需求** (State-Driven) | 如果...则 | 特定状态下的行为 | `如果 <系统状态>，则系统应当 <行为>` |
| **可选功能需求** (Optional) | 在...情况下，用户可以 | 用户可选的功能 | `在 <前提条件> 情况下，用户可以 <操作>` |
| **复合条件需求** (Complex) | 当...且...时 | 多条件组合触发 | `当 <触发条件>，且 <系统状态> 时，系统应当 <响应>` |

#### 步骤 1.1: 需求分解

从用户描述中提取以下要素：

```markdown
## 需求分解工作表

**原始需求**: [用户输入的需求描述]

### 参与者识别
- **主要用户**: [谁在使用这个功能？]
- **次要用户**: [还有谁会受影响？]
- **系统角色**: [系统在其中扮演什么角色？]

### 动作识别
- **用户动作**: [用户会执行什么操作？]
- **系统响应**: [系统应该如何响应？]
- **后置动作**: [操作完成后发生什么？]

### 条件识别
- **前提条件**: [什么情况下可以执行？]
- **触发条件**: [什么事件触发这个功能？]
- **异常条件**: [什么情况下会失败？]

### 数据识别
- **输入数据**: [需要什么输入？]
- **输出数据**: [产生什么输出？]
- **状态变化**: [什么数据会被修改？]
```

#### 步骤 1.2: EARS 转换

将分解后的需求转换为 EARS 格式句子：

**转换规则**：

1. **主流程 → 事件驱动需求**
   - 用户的核心操作流程
   - 格式: `当 <用户执行某操作> 时，系统应当 <执行对应响应>`

2. **前提条件 → 条件需求**
   - 功能可用的前提状态
   - 格式: `如果 <满足某条件>，则系统应当 <允许/执行某行为>`

3. **异常处理 → 复合条件需求**
   - 异常情况的处理
   - 格式: `当 <用户执行某操作>，且 <发生异常情况> 时，系统应当 <错误处理>`

4. **通用约束 → 无条件需求**
   - 系统始终要满足的约束
   - 格式: `系统应当 <约束条件>`

5. **可选功能 → 可选功能需求**
   - 用户可选择使用的功能
   - 格式: `在 <某条件下>，用户可以 <选择执行某操作>`

#### 步骤 1.3: 需求编号

为每条 EARS 需求分配唯一编号：

```
[功能前缀]-[类型]-[序号]

功能前缀: 2-4个大写字母，代表功能域
类型代码:
  - UB: 无条件需求 (Ubiquitous)
  - EV: 事件驱动需求 (Event-Driven)
  - ST: 条件需求 (State-Driven)
  - OP: 可选功能需求 (Optional)
  - CX: 复合条件需求 (Complex)
序号: 三位数字，从001开始

示例: AUTH-EV-001, PAY-ST-002
```

---

### 阶段 2: 生成 EARS 文档

**目标**: 生成结构化的 EARS 需求文档

#### 步骤 2.1: 确定文件名

1. **生成简短名称**:
   - 从需求描述中提取 2-4 个关键词
   - 使用中文或英文，保持简洁
   - 示例: "用户认证", "支付集成", "订单管理"

2. **分配文档编号**:
   - 扫描 `.docs/EARS/` 目录
   - 找到最大编号 N
   - 新文档使用 N+1
   - 如果目录为空，从 001 开始

3. **生成文件路径**:
   ```
   .docs/EARS/[NNN]-[简短名称].md
   示例: .docs/EARS/001-用户认证.md
   ```

#### 步骤 2.2: 生成文档内容

创建 EARS 需求文档，使用以下模板：

```markdown
# EARS 需求文档: [功能名称]

**文档编号**: [NNN]
**创建时间**: [YYYY-MM-DD]
**状态**: 草稿 | 已确认 | 已转换
**原始需求**: 
> [用户输入的原始需求描述]

---

## 1. 需求概述

### 1.1 背景
[功能背景和业务价值描述]

### 1.2 目标
[功能要达成的主要目标]

### 1.3 范围
- **包含**: [功能范围内的内容]
- **不包含**: [明确排除的内容]

---

## 2. 参与者

| 参与者 | 类型 | 描述 |
|--------|------|------|
| [参与者1] | 主要用户 | [描述] |
| [参与者2] | 次要用户 | [描述] |
| 系统 | 系统 | [系统角色描述] |

---

## 3. EARS 需求列表

### 3.1 无条件需求 (Ubiquitous)

| 编号 | 需求描述 | 验证方法 |
|------|----------|----------|
| [XX-UB-001] | 系统应当 [功能描述] | [如何验证] |

### 3.2 事件驱动需求 (Event-Driven)

| 编号 | 触发条件 | 系统响应 | 验证方法 |
|------|----------|----------|----------|
| [XX-EV-001] | 当 [触发条件] 时 | 系统应当 [响应] | [如何验证] |
| [XX-EV-002] | 当 [触发条件] 时 | 系统应当 [响应] | [如何验证] |

### 3.3 条件需求 (State-Driven)

| 编号 | 前提状态 | 系统行为 | 验证方法 |
|------|----------|----------|----------|
| [XX-ST-001] | 如果 [系统状态] | 则系统应当 [行为] | [如何验证] |

### 3.4 可选功能需求 (Optional)

| 编号 | 前提条件 | 可选操作 | 验证方法 |
|------|----------|----------|----------|
| [XX-OP-001] | 在 [前提条件] 情况下 | 用户可以 [操作] | [如何验证] |

### 3.5 复合条件需求 (Complex)

| 编号 | 触发条件 | 系统状态 | 系统响应 | 验证方法 |
|------|----------|----------|----------|----------|
| [XX-CX-001] | 当 [触发] | 且 [状态] 时 | 系统应当 [响应] | [如何验证] |

---

## 4. 业务规则

| 规则编号 | 规则描述 | 适用需求 |
|----------|----------|----------|
| BR-001 | [业务规则描述] | [关联的需求编号] |

---

## 5. 数据需求

### 5.1 输入数据

| 数据项 | 类型 | 必填 | 约束 | 说明 |
|--------|------|------|------|------|
| [数据项] | [类型] | 是/否 | [约束条件] | [说明] |

### 5.2 输出数据

| 数据项 | 类型 | 说明 |
|--------|------|------|
| [数据项] | [类型] | [说明] |

---

## 6. 非功能需求

### 6.1 性能需求
- [性能相关需求]

### 6.2 安全需求
- [安全相关需求]

### 6.3 可用性需求
- [可用性相关需求]

---

## 7. 待澄清事项

| 编号 | 问题 | 影响范围 | 建议选项 |
|------|------|----------|----------|
| Q1 | [待确认的问题] | [影响哪些需求] | A: ... / B: ... |

---

## 8. 修订历史

| 版本 | 日期 | 修改内容 | 修改人 |
|------|------|----------|--------|
| 1.0 | [日期] | 初始创建 | AI |

---

## 下一步

✅ **需求文档已生成**

请检查以上 EARS 格式需求是否准确反映了您的需求意图。

**如果需要修改**: 请告诉我需要调整的内容，我会更新文档。

**如果确认无误**: 可以使用以下命令继续 SDD 开发流程：

```bash
/speckit.specify .docs/EARS/[当前文档名]
```
```

---

### 阶段 3: 修改模式（如果是更新现有文档）

**目标**: 在现有 EARS 文档基础上进行修改

#### 步骤 3.1: 加载现有文档

1. 读取指定的 EARS 文档
2. 解析文档结构
3. 展示当前需求列表

#### 步骤 3.2: 理解修改意图

根据用户输入判断修改类型：

| 修改类型 | 关键词 | 操作 |
|----------|--------|------|
| 新增需求 | "增加"、"添加"、"新增" | 在对应章节添加新的 EARS 需求 |
| 修改需求 | "修改"、"更新"、"改为" | 更新指定编号的需求 |
| 删除需求 | "删除"、"移除"、"去掉" | 移除指定需求 |
| 澄清问题 | "Q1"、"问题1"、"选A" | 处理待澄清事项 |

#### 步骤 3.3: 执行修改

1. 按照修改类型更新文档
2. 更新修订历史
3. 重新检查需求编号连续性
4. 保存文档

---

## 通用指南

### EARS 编写最佳实践

1. **一个需求一件事**: 每条 EARS 需求只描述一个具体的功能点
2. **可测试性**: 每条需求必须是可验证的
3. **无歧义**: 避免使用"可能"、"一般"、"等等"等模糊词汇
4. **主动语态**: 使用"系统应当"而非"应该被"
5. **具体数值**: 用具体数字替代"快速"、"大量"等词汇

### 常见转换示例

**原始需求**: "用户可以登录系统"

**EARS 转换**:
```markdown
| AUTH-EV-001 | 当 用户输入正确的用户名和密码并点击登录按钮 时 | 系统应当 验证凭据并跳转到首页 |
| AUTH-EV-002 | 当 用户输入错误的用户名或密码并点击登录按钮 时 | 系统应当 显示错误提示并保留用户名输入 |
| AUTH-ST-001 | 如果 用户已登录 | 则系统应当 自动跳转到首页而非登录页 |
| AUTH-CX-001 | 当 用户尝试登录，且 连续失败超过5次 时 | 系统应当 锁定账户15分钟并发送安全通知 |
```

### 与 SDD 工作流的集成

EARS 需求文档与 spec-kit 的关系：

| EARS 文档内容 | 对应 Spec 章节 |
|---------------|----------------|
| 事件驱动需求 | 用户场景与测试 |
| 条件需求 | 边界情况 |
| 业务规则 | 功能需求 |
| 数据需求 | 关键实体 |
| 非功能需求 | 成功标准 |

### 错误处理

| 场景 | 处理方式 |
|------|----------|
| 需求描述过于模糊 | 询问用户补充关键信息（参与者、触发条件、预期结果） |
| 需求范围过大 | 建议拆分为多个 EARS 文档 |
| 技术实现混入需求 | 提取业务本质，移除技术细节 |
| 编号冲突 | 自动重新分配编号 |

---

## 上下文

{ARGS}
