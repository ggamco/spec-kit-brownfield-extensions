---
description: 为棕地项目(已有项目)生成SDD工作流所需的全部准备文件，包括constitution.md、模板文件等，使项目可直接进入规范驱动开发模式。
handoffs:
  - label: 创建功能规范
    agent: /speckit.specify
    prompt: 基于项目章程创建新功能规范。我想要构建...
  - label: 验证SDD就绪状态
    agent: /speckit.analyze
    prompt: 验证SDD准备文件的完整性和一致性
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你**必须**考虑用户输入（如果不为空）。

---

# 棕地项目SDD引导系统 (Brownfield SDD Bootstrap)

## 概述

此命令用于将**已有项目（棕地项目）**引入规范驱动开发(SDD)工作流。与 `specify init` 从零开始不同，此命令会：

1. **逆向分析**现有代码库，提取架构DNA
2. **生成定制化**的项目章程(constitution.md)，反映项目实际原则
3. **适配模板**到项目特定的技术栈和编码风格
4. **验证就绪状态**确保SDD工作流可立即启用

## ⚠️ 前置条件检查

> **🚨 关键：此命令需要先初始化spec-kit！**

**运行此命令前，请验证以下内容：**

```bash
# 检查1：.specify/ 目录存在（由 `specify init` 创建）
test -d .specify && echo "✅ .specify/ 存在" || echo "❌ 缺少 .specify/ - 请先运行 'specify init --here --ai claude --force'"

# 检查2：核心命令存在（来自spec-kit模板）
test -f .claude/commands/speckit.specify.md && echo "✅ 核心命令存在" || echo "❌ 缺少核心命令 - 请先运行 'specify init --here'"
```

**如果检查失败，必须先运行：**

```bash
# 先在当前目录初始化spec-kit
specify init --here --ai claude --force
```

**为什么需要这样做：**
- 此扩展**定制化**现有的spec-kit配置
- 核心命令（`/speckit.specify`、`/speckit.plan`、`/speckit.tasks`）来自 `specify init`，而非此扩展
- 此命令将用项目特定的版本**覆盖** constitution.md 和模板

## ⚠️ 关键：目标目录结构

> **🚨 强制约束 - 必读**
>
> 本提示词生成的所有文件**必须且只能**使用以下目录结构。
> **任何偏离都将导致 spec-kit 工具链无法工作**。
> 在生成任何文件前，请反复确认路径正确性。

**必须严格遵循以下目录结构**，这是 spec-kit 工具链正常工作的前提：

```
[项目根目录]/
├── .specify/                          # SDD配置目录（工具链依赖此路径）
│   ├── memory/
│   │   └── constitution.md            # 项目章程（核心文件）
│   ├── templates/
│   │   ├── spec-template.md           # 功能规范模板
│   │   ├── plan-template.md           # 实施计划模板
│   │   └── tasks-template.md          # 任务清单模板
│   └── scripts/                       # 工作流脚本（可选，完整安装时包含）
│       ├── bash/
│       └── pwsh/
└── specs/                             # 功能规范工作目录
    └── [###-feature-name]/            # 按功能分支组织
        ├── spec.md
        ├── plan.md
        └── tasks.md
```

**重要说明**：
- `.specify/` 目录名**必须**以点开头，不是 `specify/`
- 模板文件**必须**放在 `.specify/templates/` 下，不是根目录的 `templates/`
- 章程文件**必须**放在 `.specify/memory/constitution.md`
- `specs/` 目录在根目录下，用于存放每个功能的规范文件

### 🚨 输出前强制自检清单

**在输出任何文件前，必须逐条确认以下检查项全部通过：**

| # | 检查项 | 正确 ✓ | 错误 ✗ | 验证方法 |
|---|--------|--------|--------|----------|
| 1 | 配置目录名称 | `.specify/` | `specify/` | 必须以点开头 |
| 2 | 章程文件路径 | `.specify/memory/constitution.md` | `memory/constitution.md` | 必须在 .specify 下 |
| 3 | 模板目录路径 | `.specify/templates/` | `templates/` | 必须在 .specify 下 |
| 4 | 规范目录路径 | `specs/` (根目录) | `.specify/specs/` | 不在 .specify 下 |
| 5 | 模板文件完整 | 3个模板文件全部生成 | 遗漏任一模板 | spec/plan/tasks |

**❌ 如果任一检查项失败，必须立即修正后再输出**

---

## 执行流程

### 阶段 0: 项目发现 (Project Discovery)

**目标**: 系统性扫描项目，提取核心特征

#### 步骤 0.1: 结构扫描

首先，执行全面的项目结构扫描：

1. **识别项目根目录标识文件**：
    - 包管理器: `package.json`, `pom.xml`, `build.gradle`, `Cargo.toml`, `pyproject.toml`, `go.mod`, `Gemfile`, `composer.json`
    - 配置文件: `.editorconfig`, `.prettierrc`, `.eslintrc.*`, `tsconfig.json`, `tox.ini`, `setup.cfg`
    - 版本控制: `.git/`, `.gitignore`, `.gitattributes`
    - CI/CD: `.github/workflows/`, `.gitlab-ci.yml`, `Jenkinsfile`, `azure-pipelines.yml`
    - 容器化: `Dockerfile`, `docker-compose.yml`, `kubernetes/`

2. **扫描目录结构**：
   ```bash
   # 获取项目结构（深度3层，排除常见忽略目录）
   find . -maxdepth 3 -type d \
     ! -path '*/node_modules/*' \
     ! -path '*/.git/*' \
     ! -path '*/vendor/*' \
     ! -path '*/__pycache__/*' \
     ! -path '*/target/*' \
     ! -path '*/build/*' \
     ! -path '*/dist/*' \
     -print
   ```

3. **统计代码分布**：
    - 识别主要编程语言（按文件数量和代码行数）
    - 识别测试目录位置和测试框架
    - 识别文档位置（docs/, README.*, CONTRIBUTING.md等）

#### 步骤 0.2: 技术栈提取

基于扫描结果，构建技术栈画像：

```markdown
## 技术栈画像

**主要语言**: [识别的主要语言及版本]
**框架/运行时**: [识别的主要框架]
**包管理器**: [识别的包管理工具]
**构建工具**: [识别的构建系统]
**测试框架**: [识别的测试工具]
**数据存储**: [识别的数据库/缓存]
**部署平台**: [识别的部署目标]
**CI/CD系统**: [识别的CI/CD工具]
```

#### 步骤 0.3: 架构模式识别

分析代码结构以识别架构模式：

1. **目录命名模式分析**：
    - `src/controllers/`, `src/handlers/` → MVC/分层架构
    - `src/domain/`, `src/application/`, `src/infrastructure/` → 洋葱/六边形架构
    - `services/`, `microservices/` → 微服务架构
    - `modules/`, `packages/` → 模块化单体
    - `frontend/`, `backend/` → 前后端分离

2. **代码组织模式**：
    - 按功能组织（feature-based）
    - 按层组织（layer-based）
    - 按领域组织（domain-based）

3. **常见模式检测**：
    - Repository Pattern: `*Repository.*`, `*Repo.*`
    - Service Layer: `*Service.*`, `*Manager.*`
    - Factory Pattern: `*Factory.*`
    - DTO/VO: `*DTO.*`, `*VO.*`, `*Model.*`

#### 步骤 0.4: 编码规范提取

从现有代码中提取实际遵循的规范：

1. **从配置文件提取**：
    - ESLint/Prettier配置 → JavaScript/TypeScript规范
    - .editorconfig → 通用格式规范
    - pylint/flake8/black配置 → Python规范
    - checkstyle/spotless配置 → Java规范

2. **从代码样本推断**：
    - 命名约定（camelCase, snake_case, PascalCase）
    - 文件命名模式（kebab-case.ts, PascalCase.java）
    - 注释风格（JSDoc, docstring, Javadoc）
    - 导入组织方式

3. **从Git历史推断**（可选）：
    - 提交消息格式
    - 分支命名策略
    - PR/MR模板

#### 步骤 0.5: 多模块/多子项目分析 ⚠️ 关键

**对于包含多个子模块的项目（如 Java Maven/Gradle 多模块、Node.js Monorepo 等），必须执行此步骤**。

##### 1. 识别多模块项目类型

| 项目类型 | 识别特征 | 识别方法 |
|----------|----------|----------|
| **Maven 多模块** | 根目录 `pom.xml` 包含 `<modules>` | 解析 `pom.xml` 中的 `<modules>` 标签 |
| **Gradle 多模块** | 根目录 `settings.gradle(.kts)` 包含 `include` | 解析 `include` 语句 |
| **Node.js Monorepo** | 根目录 `package.json` 包含 `workspaces` | 解析 `workspaces` 配置 |
| **Go Workspace** | 存在 `go.work` 文件 | 解析 `use` 指令 |
| **Rust Workspace** | `Cargo.toml` 包含 `[workspace]` | 解析 `members` 配置 |
| **Python Monorepo** | 多个 `pyproject.toml` 或 `setup.py` | 搜索多个包定义文件 |

##### 2. 枚举所有子模块

**必须扫描并列出项目中的所有子模块**：

```markdown
## 子模块清单

| 模块名 | 路径 | 模块类型 | 打包方式 |
|--------|------|----------|----------|
| [module-1] | [path/to/module-1] | [jar/war/pom/lib] | [artifact类型] |
| [module-2] | [path/to/module-2] | [jar/war/pom/lib] | [artifact类型] |
| ... | ... | ... | ... |
```

**Java Maven 项目示例**：
```bash
# 解析父 pom.xml 获取所有子模块
grep -oP '(?<=<module>)[^<]+' pom.xml
```

**Java Gradle 项目示例**：
```bash
# 解析 settings.gradle 获取所有子模块
grep -oP "include\s*['\"]([^'\"]+)['\"]" settings.gradle
```

##### 3. 分析子模块职责

**对每个子模块进行职责分析和分类**：

| 模块分类 | 典型命名模式 | 职责描述 |
|----------|--------------|----------|
| **API/接口层** | `*-api`, `*-interface`, `*-facade` | 对外暴露的接口定义，DTO/VO |
| **服务实现层** | `*-service`, `*-impl`, `*-core` | 业务逻辑实现 |
| **数据访问层** | `*-dao`, `*-repository`, `*-persistence` | 数据库操作，Entity 定义 |
| **通用工具层** | `*-common`, `*-utils`, `*-base` | 共享工具类，基础设施 |
| **Web/控制器层** | `*-web`, `*-controller`, `*-rest` | HTTP 端点，请求处理 |
| **启动/引导模块** | `*-app`, `*-boot`, `*-starter` | 应用启动入口，配置汇总 |
| **领域模块** | `*-domain`, `*-model` | 领域模型，业务实体 |
| **集成/适配器** | `*-integration`, `*-adapter`, `*-client` | 第三方系统集成 |

**生成模块职责映射表**：

```markdown
## 模块职责映射

| 模块 | 职责分类 | 核心职责 | 可放置的代码类型 |
|------|----------|----------|------------------|
| user-api | API/接口层 | 用户服务接口定义 | DTO, VO, 接口定义, 枚举 |
| user-service | 服务实现层 | 用户业务逻辑 | Service实现, 业务校验, 事务处理 |
| user-dao | 数据访问层 | 用户数据持久化 | Entity, Repository, Mapper |
| common | 通用工具层 | 共享基础设施 | 工具类, 常量, 异常定义 |
```

##### 4. 分析模块间依赖关系

**必须分析并记录模块间的依赖关系**：

**Maven 项目**：
```bash
# 分析每个模块的依赖
for module in $(grep -oP '(?<=<module>)[^<]+' pom.xml); do
  echo "=== $module ===" 
  grep -A1 '<dependency>' $module/pom.xml | grep -oP '(?<=<artifactId>)[^<]+'
done
```

**生成依赖关系图**：

```markdown
## 模块依赖关系

```
[app-boot]
├── [user-service]
│   ├── [user-api]
│   ├── [user-dao]
│   └── [common]
├── [order-service]
│   ├── [order-api]
│   ├── [order-dao]
│   ├── [user-api]  ← 跨模块依赖
│   └── [common]
└── [common]
```

### 依赖规则

- **允许的依赖方向**: 上层 → 下层（service → api → common）
- **禁止的依赖方向**: 下层 → 上层、循环依赖
- **跨领域依赖**: 仅通过 API 模块依赖，不直接依赖 Service 实现
```

##### 5. 确定新功能代码放置决策树

**基于模块分析，创建代码放置决策指南**：

```markdown
## 代码放置决策树

当需要添加新功能时，按以下决策树确定代码位置：

1. **这是对外暴露的接口/DTO吗？**
   - 是 → 放入对应领域的 `*-api` 模块
   - 否 → 继续

2. **这是业务逻辑/服务实现吗？**
   - 是 → 放入对应领域的 `*-service` 模块
   - 否 → 继续

3. **这是数据库实体/数据访问吗？**
   - 是 → 放入对应领域的 `*-dao` 模块
   - 否 → 继续

4. **这是跨多个领域共享的工具吗？**
   - 是 → 放入 `common` 模块
   - 否 → 继续

5. **这是新的业务领域吗？**
   - 是 → 考虑创建新的模块组（xxx-api, xxx-service, xxx-dao）
   - 否 → 咨询架构师

### 模块选择速查表

| 代码类型 | 目标模块 | 示例 |
|----------|----------|------|
| 新 REST API | `[领域]-web` 或 `[领域]-controller` | UserController |
| 新 Service 接口 | `[领域]-api` | IUserService |
| Service 实现 | `[领域]-service` | UserServiceImpl |
| 数据库 Entity | `[领域]-dao` | UserEntity |
| 数据库操作 | `[领域]-dao` | UserRepository |
| DTO/VO | `[领域]-api` | UserDTO |
| 工具类 | `common` | StringUtils |
| 异常定义 | `common` 或 `[领域]-api` | UserNotFoundException |
| 配置类 | `[领域]-boot` 或 `app` | DataSourceConfig |
```

---

### 阶段 1: 生成项目章程 (Constitution Generation)

**目标**: 基于项目分析，生成项目章程

**输出文件**: `.specify/memory/constitution.md`

#### 步骤 1.1: 创建目录结构

首先创建必要的目录：

```bash
mkdir -p .specify/memory
mkdir -p .specify/templates
mkdir -p specs
```

#### 步骤 1.2: 原则推导

基于发现报告，推导项目应遵循的原则：

**原则推导逻辑**：

| 发现特征 | 推导原则 | 原则描述 |
|----------|----------|----------|
| 存在独立模块/包结构 | 模块化原则 | 功能必须作为独立模块实现，保持清晰边界 |
| 存在统一测试目录 | 测试优先原则 | 所有功能必须编写测试，测试先于实现 |
| 存在API目录/路由 | 接口契约原则 | 所有对外接口必须先定义契约 |
| 使用特定框架 | 框架约束原则 | 必须使用[框架]的惯用模式 |
| 存在统一错误处理 | 错误处理原则 | 错误必须通过统一机制处理 |
| 存在日志配置 | 可观测性原则 | 所有操作必须产生可追踪的日志 |
| 存在CI/CD配置 | 持续集成原则 | 所有变更必须通过自动化验证 |

#### 步骤 1.3: 生成项目章程

创建 `.specify/memory/constitution.md`：

```markdown
# [PROJECT_NAME] 项目章程

## 核心原则

### I. [PRINCIPLE_1_NAME]

[从代码实际模式提取的原则描述]

**来源**: [说明此原则是从哪个代码特征推导的]
**验证**: [如何验证代码符合此原则]

### II. [PRINCIPLE_2_NAME]

[原则描述]

**来源**: [推导来源]
**验证**: [验证方法]

### III. 测试纪律 (TDD 强制)

⚠️ **强制执行 TDD (测试驱动开发)**

所有新功能必须遵循 TDD 红-绿-重构循环：
1. **🔴 先写测试**: 任何实现代码前，必须先有失败的测试
2. **🟢 最小实现**: 只写让测试通过的最少代码
3. **🔵 持续重构**: 测试通过后重构，保持代码整洁

**测试框架**: [项目使用的测试框架]
**测试位置**: [测试代码的标准位置]
**覆盖要求**: 新代码 ≥ 80%，核心业务逻辑 100%
**TDD验证**: 通过 git 提交历史可验证测试先于实现

### IV. 代码风格

[从项目提取的代码风格规范]

**命名规范**: [项目的命名约定]
**格式化**: [项目的格式化配置]
**工具链**: [代码质量工具]

### V. 架构约束

[项目的架构边界和约束]

**架构风格**: [识别的架构风格]
**模块边界**: [模块划分原则]
**依赖规则**: [依赖管理规则]

### VI. 代码复用与理解原则

#### 禁止代码重复

**强制规则**: 创建新的类和方法之前，**必须**先查找现有的类和方法。

**执行步骤**:
1. 搜索项目中是否已有相似功能的类/方法
2. 检查 component/common/utils/bll/service 等共享模块
3. 确认无可复用代码后，才创建新代码

**验证方法**: 代码审查时检查是否存在重复实现

#### 理解现有代码

**工具**: 当需要理解现有代码时，使用 Repomix 为项目生成/更新 skills。

```bash
# 生成/更新项目技能文档
repomix --skill-generate
```

**使用时机**:
- 首次接触项目时
- 大型功能开发或重构前
- 代码库发生重大变化后
- `/speckit.specify` 命令前

## 技术栈锚定

**此项目的SDD规范和计划必须遵循以下技术栈**：

| 类别 | 技术 | 版本约束 | 不可替代 |
|------|------|----------|----------|
| 语言 | [语言] | [版本] | ✓ |
| 框架 | [框架] | [版本] | ✓ |
| 测试 | [测试框架] | [版本] | ✓ |
| 构建 | [构建工具] | [版本] | ✓ |

## 模块架构 *(多模块项目必填)*

### 项目类型

**项目结构**: [单模块/多模块 Maven/多模块 Gradle/Monorepo]
**模块数量**: [N] 个子模块

### 模块清单与职责

| 模块名 | 路径 | 职责分类 | 核心职责 | 可放置的代码类型 |
|--------|------|----------|----------|------------------|
| [module-api] | [path] | API/接口层 | [职责描述] | DTO, VO, 接口定义 |
| [module-service] | [path] | 服务实现层 | [职责描述] | Service实现, 业务逻辑 |
| [module-dao] | [path] | 数据访问层 | [职责描述] | Entity, Repository |
| [common] | [path] | 通用工具层 | [职责描述] | 工具类, 常量 |

### 模块依赖关系

```
[依赖关系图]
[app-boot]
├── [xxx-service]
│   ├── [xxx-api]
│   ├── [xxx-dao]
│   └── [common]
└── [common]
```

**依赖规则**:
- 允许: [上层模块] → [下层模块]
- 禁止: 循环依赖、跨领域直接依赖Service实现
- 跨领域: 仅通过 API 模块依赖

### 新功能代码放置决策

| 代码类型 | 目标模块 | 目标路径 |
|----------|----------|----------|
| 新 REST 接口 | [web模块] | [包路径] |
| 新 Service 接口 | [api模块] | [包路径] |
| Service 实现 | [service模块] | [包路径] |
| 数据库 Entity | [dao模块] | [包路径] |
| DTO/VO | [api模块] | [包路径] |
| 工具类 | [common模块] | [包路径] |

## 目录契约

**新代码必须放置在符合以下约定的位置**：

| 代码类型 | 标准位置 | 命名约定 |
|----------|----------|----------|
| 业务逻辑 | [路径] | [命名规则] |
| 数据模型 | [路径] | [命名规则] |
| API端点 | [路径] | [命名规则] |
| 测试代码 | [路径] | [命名规则] |
| 配置文件 | [路径] | [命名规则] |

## 治理

### 章程优先级

1. 本章程是SDD工作流的最高指导
2. 所有规范(spec)必须符合章程原则
3. 所有计划(plan)必须使用章程锚定的技术栈
4. 所有任务(tasks)必须遵守目录契约

### 修正程序

- 修改章程需要记录变更理由
- 必须更新依赖此章程的所有模板
- 版本号遵循语义版本控制

**版本**: 1.0.0 | **创建日期**: [DATE] | **来源**: 棕地项目引导
```

#### 步骤 1.4: 用户确认

向用户展示生成的章程，请求确认或修改：

```markdown
## 章程审核

我已基于项目分析生成了项目章程。请审核以下关键决策：

### 需确认的原则

1. **[原则名]**: [原则描述]
   - 👍 确认 / ✏️ 修改 / ❌ 删除

2. **[原则名]**: [原则描述]
   - 👍 确认 / ✏️ 修改 / ❌ 删除

### 需确认的技术约束

- 主要语言是否锁定为 [语言 版本]？
- 测试框架是否锁定为 [测试框架]？
- 是否有遗漏的关键技术？

### 需确认的目录约定

当前识别的目录结构是否准确反映了代码组织方式？

请回复确认或提供修改意见。
```

---

### 阶段 2: 生成模板文件 (Template Generation)

**目标**: 生成适配项目特征的SDD模板

**输入**: 阶段1生成的 `.specify/memory/constitution.md`

#### 步骤 2.1: 生成规范模板

创建 `.specify/templates/spec-template.md`：

**适配点**：
- 用户故事格式符合项目领域
- 验收标准使用项目测试框架可验证的格式
- 需求编号符合项目现有编号体系（如有）

```markdown
# 功能规范: [FEATURE NAME]

**功能分支**: `[###-feature-name]`
**创建时间**: [DATE]
**状态**: 草稿
**输入**: 用户描述: "$ARGUMENTS"

## 用户场景与测试 *(必填)*

<!--
  重要说明: 用户故事应按重要性排序, 作为用户旅程进行优先级划分.
  每个用户故事/旅程必须能够独立测试——这意味着即使只实现其中一个, 
  你仍然应该有一个可行的 MVP(最小可行产品)来交付价值.

  技术栈约束: 本项目使用 [项目测试框架], 验收场景必须可用该框架表达.
-->

### 用户故事 1 - [简要标题] (优先级: P1)

[用通俗语言描述这个用户旅程]

**优先级原因**: [解释价值以及为什么具有此优先级]

**独立测试**: [描述如何使用项目现有测试设施验证]

**验收场景**: 

1. **给定** [初始状态], **当** [操作时], **那么** [预期结果]
2. **给定** [初始状态], **当** [操作时], **那么** [预期结果]

---

### 用户故事 2 - [简要标题] (优先级: P2)

[用通俗语言描述这个用户旅程]

**优先级原因**: [解释价值以及为什么具有此优先级]

**独立测试**: [描述如何独立测试]

**验收场景**: 

1. **给定** [初始状态], **当** [操作时], **那么** [预期结果]

---

[根据需要添加更多用户故事, 每个都分配优先级]

### 边界情况

- 当 [边界条件] 时会发生什么？
- 系统如何处理 [错误场景]？

## 需求 *(必填)*

### 功能需求

- **FR-001**: 系统必须 [具体能力]
- **FR-002**: 系统必须 [具体能力]
- **FR-003**: 用户必须能够 [关键交互]

*标记不明确需求的示例:*

- **FR-00X**: 系统必须 [NEEDS CLARIFICATION: 未指定的需求细节]

### 关键实体 *(如果功能涉及数据则包含)*

- **[实体 1]**: [它代表什么, 关键属性(不含实现细节)]
- **[实体 2]**: [它代表什么, 与其他实体的关系]

## 与现有系统的集成点

**此功能需要与以下现有模块交互**：

| 模块 | 路径 | 交互方式 | 接口类型 |
|------|------|----------|----------|
| [现有模块] | [路径] | [调用/被调用/事件] | [接口描述] |

## 成功标准 *(必填)*

### 可衡量的结果

- **SC-001**: [可衡量的指标]
- **SC-002**: [可衡量的指标]
```

#### 步骤 2.2: 生成计划模板

创建 `.specify/templates/plan-template.md`：

**适配点**：
- 技术背景预填充项目技术栈
- 项目结构反映实际目录约定
- 章程检查反映项目章程原则

```markdown
# 实施计划: [FEATURE]

**分支**: `[###-feature-name]` | **日期**: [DATE] | **规范**: specs/[###-feature-name]/spec.md

## 摘要

[功能需求摘要 + 技术实现方法]

## 技术背景（项目锚定）

⚠️ **以下技术栈由项目章程锁定，不可更改**：

**语言/版本**: [项目语言及版本]
**主要框架**: [项目框架]
**测试框架**: [项目测试框架]
**构建工具**: [项目构建工具]
**项目类型**: [单体/微服务/Monorepo]

## 章程合规检查

*必须在开始实施前全部通过*

- [ ] [章程原则1]: [具体检查项]
- [ ] [章程原则2]: [具体检查项]
- [ ] 目录契约: 所有新文件位置符合章程约定
- [ ] 命名规范: 所有命名符合项目约定

## 项目结构（遵循现有约定）

### 新增/修改文件

```
[项目根目录]
├── [现有目录结构]
│   └── [新增文件，使用项目命名约定]
└── [测试目录]
└── [新增测试文件]
```

### 集成点

| 现有模块 | 位置 | 集成方式 | 变更类型 |
|----------|------|----------|----------|
| [模块名] | [路径] | [方式] | 新增/修改 |

## 实施阶段

### 阶段 0: 验证与准备

- 确认章程检查通过
- 确认与现有代码无冲突
- 确认依赖版本兼容

### 阶段 1: 核心实现

[遵循项目架构模式的实现步骤]

### 阶段 2: 集成与测试

[使用项目测试框架的测试策略]
```

#### 步骤 2.3: 生成任务模板

创建 `.specify/templates/tasks-template.md`：

**适配点**：
- 路径使用项目实际目录结构
- 任务描述使用项目命名约定
- 测试任务使用项目测试框架

```markdown
# 任务: [FEATURE NAME]

**功能目录**: specs/[###-feature-name]/
**前置条件**: plan.md（必需）, spec.md（必需）
**章程约束**: .specify/memory/constitution.md

## 路径约定（项目锚定）

⚠️ **以下路径由项目章程锁定**：

- **业务代码**: [项目业务代码路径]
- **数据模型**: [项目模型路径]
- **测试代码**: [项目测试路径]
- **配置文件**: [项目配置路径]

## 阶段 1: 设置与验证

- [ ] T001 验证章程合规性检查
- [ ] T002 确认与现有代码无命名冲突
- [ ] T003 确认依赖版本兼容

## 阶段 2: 基础设施

**⚠️ 关键**: 仅添加必要的新依赖，优先复用现有模块

- [ ] T004 [如需] 在 [项目依赖配置] 添加新依赖
- [ ] T005 [如需] 创建共享类型/接口定义

## 阶段 3: 用户故事 1 - [标题] (P1)

### 🔴 TDD Phase 1: 编写失败测试

- [ ] T006 [P] 在 [项目测试路径]/[命名约定] 编写测试
- [ ] T007 **运行测试，确认失败** ← 🔴 必须先失败

### 🟢 TDD Phase 2: 最小实现

- [ ] T008 [P] 在 [项目代码路径]/[命名约定] 创建[组件]
- [ ] T009 实现**最少代码**让测试通过
- [ ] T010 **运行测试，确认通过** ← 🟢 必须通过

### 🔵 TDD Phase 3: 重构

- [ ] T011 重构代码，改善结构
- [ ] T012 **运行测试，确认仍通过** ← 🔵 不可破坏

**检查点**: 运行 `[项目测试命令]` 验证

## 阶段 N: 集成验证

- [ ] TXXX 运行完整测试套件: `[项目测试命令]`
- [ ] TXXX 运行代码检查: `[项目lint命令]`
- [ ] TXXX 验证与现有功能无回归
```

---

### 阶段 3: 验证与整合 (Validation & Integration)

**目标**: 验证生成文件的完整性和一致性，确保SDD工作流可立即启用

#### 步骤 3.1: 完整性检查

验证所有必需文件已生成：

```markdown
## SDD就绪检查清单

### 目录结构验证

- [ ] `.specify/` 目录已创建
- [ ] `.specify/memory/` 目录已创建
- [ ] `.specify/templates/` 目录已创建
- [ ] `specs/` 目录已创建

### 核心文件验证

- [ ] `.specify/memory/constitution.md` - 项目章程 ✓
- [ ] `.specify/templates/spec-template.md` - 规范模板 ✓
- [ ] `.specify/templates/plan-template.md` - 计划模板 ✓
- [ ] `.specify/templates/tasks-template.md` - 任务模板 ✓
```

#### 步骤 3.2: 一致性验证

验证各文件之间的引用一致性：

1. **章程↔模板一致性**：
    - 模板中的技术栈与章程锁定的技术栈一致
    - 模板中的路径约定与章程目录契约一致
    - 模板中的章程检查项与章程原则对应

2. **模板↔模板一致性**：
    - spec-template的需求格式与plan-template的引用方式兼容
    - plan-template的阶段划分与tasks-template的任务组织一致

3. **模板↔项目一致性**：
    - 模板中的路径在项目中确实存在
    - 模板中的命令可在项目中执行

#### 步骤 3.3: 生成验收报告

```markdown
## 棕地项目SDD引导完成报告

**项目**: [项目名称]
**完成时间**: [日期]
**引导状态**: ✅ 成功 / ⚠️ 需要手动干预 / ❌ 失败

### 🚨 输出文件最终校验 *(必须全部通过)*

| 文件 | 预期路径 | 实际路径 | 校验结果 |
|------|----------|----------|----------|
| 项目章程 | `.specify/memory/constitution.md` | [填写实际路径] | ✅/❌ |
| 规范模板 | `.specify/templates/spec-template.md` | [填写实际路径] | ✅/❌ |
| 计划模板 | `.specify/templates/plan-template.md` | [填写实际路径] | ✅/❌ |
| 任务模板 | `.specify/templates/tasks-template.md` | [填写实际路径] | ✅/❌ |

**⚠️ 如有任何 ❌，必须修正后重新输出该文件**

### 生成文件清单

| 文件 | 路径 | 状态 | 备注 |
|------|------|------|------|
| 项目章程 | `.specify/memory/constitution.md` | ✅ | 核心文件 |
| 规范模板 | `.specify/templates/spec-template.md` | ✅ | |
| 计划模板 | `.specify/templates/plan-template.md` | ✅ | |
| 任务模板 | `.specify/templates/tasks-template.md` | ✅ | |
| 规范目录 | `specs/` | ✅ | 空目录 |

### 章程摘要

**核心原则**:
1. [原则1名称]
2. [原则2名称]
3. [原则3名称]

**技术栈锁定**:
- 语言: [语言]
- 框架: [框架]
- 测试: [测试框架]

### 下一步操作

项目已准备好进入SDD工作流：

1. **审核章程**: 检查 `.specify/memory/constitution.md`，确认章程原则符合项目实际
2. **开始第一个功能**: 使用 `/speckit.specify` 或 `specify-cn` 命令创建第一个功能规范
3. **查看帮助**: 运行 `specify-cn --help` 了解所有可用命令

### 常用命令

```bash
# 创建新功能分支并初始化规范
specify-cn

# 查看当前功能状态
specify-cn status

# 生成实施计划
# 使用 /speckit.plan 命令

# 生成任务清单
# 使用 /speckit.tasks 命令
```

### 注意事项

- [发现的潜在问题]
- [需要手动处理的项目]
```

---

## 🧪 TDD 测试驱动开发纪律 *(强制)*

### TDD 核心原则

**所有新功能开发必须严格遵循 TDD 红-绿-重构 循环**：

```
┌─────────────────────────────────────────────────────────────┐
│                    TDD 开发循环 (强制)                       │
├─────────────────────────────────────────────────────────────┤
│  1. 🔴 RED    │ 先写失败的测试 → 运行测试 → 确认失败       │
│  2. 🟢 GREEN  │ 写最少代码让测试通过 → 运行测试 → 确认通过 │
│  3. 🔵 REFACTOR │ 重构代码 → 运行测试 → 确认仍然通过       │
│  4. 🔁 REPEAT │ 返回步骤1，处理下一个测试用例              │
└─────────────────────────────────────────────────────────────┘
```

### TDD 执行规则

| 规则 | 描述 | 违反后果 |
|------|------|----------|
| **先测试后实现** | 任何业务代码编写前，必须先存在对应的失败测试 | 代码审查不通过 |
| **最小实现** | 每次只写让当前测试通过的最少代码 | 避免过度设计 |
| **测试即文档** | 测试用例命名必须清晰描述业务场景 | 可维护性差 |
| **100%新代码覆盖** | 所有新增业务逻辑必须有对应测试 | 不可合并 |

### TDD 在 SDD 工作流中的位置

```
规范(Spec) → 计划(Plan) → 任务(Tasks) → [TDD循环] → 完成
│
┌─────────────────┴─────────────────┐
│  每个任务内部:                    │
│  T1: 编写测试用例 (🔴 预期失败)   │
│  T2: 运行测试确认失败             │
│  T3: 实现功能代码 (🟢 最小实现)   │
│  T4: 运行测试确认通过             │
│  T5: 重构优化 (🔵 保持测试通过)   │
└───────────────────────────────────┘
```

### TDD 检查点 *(每个用户故事实现后必须验证)*

- [ ] 所有验收场景都有对应的测试用例
- [ ] 测试先于实现代码存在（可通过 git 历史验证）
- [ ] 测试用例命名清晰表达业务意图
- [ ] 新增代码测试覆盖率 ≥ 80%（核心业务逻辑 100%）
- [ ] 所有测试通过后才进行代码提交

---

## 通用指南

### 棕地项目特殊考量

1. **尊重现有架构**: 不要试图"改进"现有架构，而是准确反映它
2. **技术栈锁定**: 棕地项目的技术栈是既定事实，章程必须锚定它
3. **渐进式引入**: SDD工作流应无缝融入现有开发流程
4. **兼容性优先**: 所有生成的代码必须与现有代码风格一致
5. **禁止代码重复**: 创建新的类和方法之前，必须先查找现有的类和方法，如果没有可重用的代码，才创建新代码
6. **理解现有代码**: 当需要理解现有代码时，使用Repomix为项目生成/更新skills，命令：`repomix --skill-generate`

### 路径引用规范

**在模板文件中引用其他文件时**：

| 引用对象 | 正确路径 | 错误路径 |
|----------|----------|----------|
| 项目章程 | `.specify/memory/constitution.md` | `memory/constitution.md` |
| 规范模板 | `.specify/templates/spec-template.md` | `templates/spec-template.md` |
| 功能规范 | `specs/[###-feature]/spec.md` | `.specify/specs/[###-feature]/spec.md` |

### 处理不确定性

当无法从代码中确定某些约定时：

1. **优先使用行业标准**: 基于技术栈的最佳实践
2. **标记待确认**: 使用 `[NEEDS CLARIFICATION: 问题描述]` 标记
3. **限制数量**: 最多3个待确认项
4. **提供选项**: 为每个待确认项提供2-3个建议选项

### 错误处理

| 场景 | 处理方式 |
|------|----------|
| 无法识别项目类型 | 询问用户确认主要技术栈 |
| 目录结构异常 | 使用标准结构但标记为"非标准项目" |
| 无测试代码 | 章程中添加"建立测试实践"原则 |
| 多语言项目 | 识别主要语言，章程中列出所有语言 |

---

## 上下文

{ARGS}